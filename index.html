<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>DQ1風プロトタイプ (IndexedDB & SweetAlert2 統一版)</title>
  <!-- Tailwind CSS (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Font: Press Start 2P -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <!-- SweetAlert2 (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <style>
    body {
      background-color: #000;
      color: #fff;
      font-family: 'Press Start 2P', cursive;
      margin: 0;
      padding: 10px;
      overflow: hidden;
    }
    /* マップ表示領域（10×10タイル、各タイル32px固定） */
    .map-container {
      width: 320px;
      height: 320px;
      margin: 0 auto;
      position: relative;
      overflow: hidden;
    }
    .tile {
      width: 32px;
      height: 32px;
      box-sizing: border-box;
      border: 1px solid #444;
      text-align: center;
      line-height: 32px;
      font-size: 10px;
      white-space: nowrap;
      overflow: hidden;
    }
    /* 地形、町、NPC など */
    .grass { background-color: #008000; }
    .road { background-color: #a0a0a0; }
    .forest { background-color: #006400; }
    .mountain { background-color: #8b4513; }
    .water { background-color: #1e90ff; }
    .pavement { background-color: #696969; }
    .building { background-color: #333333; }
    .townGate { background-color: #604020; }
    .npc { background-color: #ffa0a0; }
    .exit { background-color: #222222; }
    .hero { background-color: #ff0000; font-weight: bold; }
    .message-window {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: rgba(0,0,0,0.8);
      padding: 4px;
      font-size: 10px;
      text-align: center;
    }
    /* コントロールパネル (DPad) */
    .control-panel {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 120px;
      height: 120px;
      z-index: 999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
    }
    .control-row { display: flex; justify-content: center; }
    .control-btn {
      width: 50px;
      height: 50px;
      font-size: 20px;
      margin: 2px;
      line-height: 50px;
      text-align: center;
      user-select: none;
    }
    /* 戦闘画面 */
    .battle-container {
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      height: 100vh;
      box-sizing: border-box;
    }
    .battle-top {
      display: flex;
      flex: 1;
    }
    .battle-left, .battle-center, .battle-right {
      padding: 8px;
      box-sizing: border-box;
    }
    .battle-left, .battle-right {
      width: 30%;
      font-size: 12px;
      overflow: auto;
    }
    .battle-center {
      width: 40%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      border-left: 1px solid #fff;
      border-right: 1px solid #fff;
    }
    .battle-footer {
      background-color: #222;
      display: flex;
      flex-direction: column;
      height: 20vh;
      min-height: 60px;
      padding: 8px;
      box-sizing: border-box;
    }
    .battle-footer .message-area {
      flex: 1;
      overflow-y: auto;
      padding: 4px;
      border-bottom: 1px solid #444;
      background-color: rgba(255,255,255,0.1);
      min-height: 5em; /* 最低5行分 */
    }
    .battle-footer .actions {
      margin-top: 4px;
      display: flex;
      justify-content: space-around;
    }
    .battle-footer button {
      background-color: #444;
      color: #fff;
      border: none;
      padding: 6px 8px;
      margin: 0 4px;
      border-radius: 4px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <!-- Vue3 (CDN) -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script>
    /***************************************
     * SweetAlert2 ユーティリティ
     ***************************************/
    const toast = Swal.mixin({
      toast: true,
      position: 'top-end',
      showConfirmButton: false,
      timer: 3000,
      timerProgressBar: true,
      background: '#333',
      color: '#fff'
    });
    function showToast(message, icon = 'success') {
      toast.fire({ icon, title: message });
    }
    function showModal(options) {
      return Swal.fire(Object.assign({
        background: '#fff',
        color: '#000',
        confirmButtonText: 'OK'
      }, options));
    }

    /***************************************
     * IndexedDB 初期化＆ゲームデータ管理
     ***************************************/
    // バージョンを2に更新
    const DB_NAME = "GameDB";
    const DB_VERSION = 2;
    const STORE_NAME = "gameData";
    let dbInstance = null;
    function initDB() {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = function(e) {
        const db = e.target.result;
        if(!db.objectStoreNames.contains(STORE_NAME)) {
          db.createObjectStore(STORE_NAME, { keyPath: "id" });
        }
      };
      req.onsuccess = function(e) {
        dbInstance = e.target.result;
        loadGameData();
      };
      req.onerror = function(e) {
        console.error("IndexedDB エラー", e);
      };
    }
    // デフォルトのゲームデータ。各種データの器として fields も追加
    const defaultGameData = {
      id: "default",
      enemyData: [
        { name: "スライム", hp: 10, attack: 2, defense: 1, magicAttack: 0, magicDefense: 0, reward: { gold: 30, exp: 10, item: null } },
        { name: "ドラキー", hp: 15, attack: 3, defense: 2, magicAttack: 0, magicDefense: 1, reward: { gold: 50, exp: 15, item: null } },
        { name: "キメラ", hp: 20, attack: 5, defense: 2, magicAttack: 4, magicDefense: 2, reward: { gold: 80, exp: 20, item: "羽" } }
      ],
      itemData: {
        consumables: [
          { name: "回復薬", price: 10, effect: "smallHeal", type: "consumable" },
          { name: "毒消し草", price: 8, effect: "curePoison", type: "consumable" }
        ],
        weapons: [
          { name: "こんぼう", price: 50, power: 2, type: "weapon" },
          { name: "どうのつるぎ", price: 180, power: 8, type: "weapon" }
        ],
        armors: [
          { name: "ぬののふく", price: 20, power: 2, type: "armor" },
          { name: "かわのよろい", price: 70, power: 4, type: "armor" }
        ]
      },
      magicData: [
        { name: "ホイミ", mpCost: 3, type: "heal", power: 12 },
        { name: "ギラ", mpCost: 3, type: "attack", power: 7 },
        { name: "ベギラマ", mpCost: 5, type: "attack", power: 15 }
      ],
      levelUpCriteria: [10, 30, 60, 100, 150],
      // 各マップ／フィールドの器。将来的に拡張可能な階層管理用。
      fields: [
        {
          id: "field001",
          name: "草原",
          type: "野外",
          // layout はここでは空の配列またはサンプルの2次元配列を設定
          layout: [],
          terrainProperties: {
            grass: { passable: true, encounterRate: 0.1 },
            forest: { passable: true, encounterRate: 0.3 },
            mountain: { passable: false, encounterRate: 0 },
            desert: { passable: true, encounterRate: 0.05 },
            rock: { passable: false, encounterRate: 0 }
          },
          enemySettings: {
            availableEnemies: ["スライム", "ドラキー"],
            baseEncounterRate: 0.1
          },
          events: []
        }
      ]
    };
    function loadGameData() {
      if(!dbInstance) return;
      const transaction = dbInstance.transaction([STORE_NAME], "readonly");
      const store = transaction.objectStore(STORE_NAME);
      const req = store.get("default");
      req.onsuccess = function(e) {
        if(e.target.result) {
          Object.assign(defaultGameData, e.target.result);
          console.log("IndexedDBからゲームデータをロードしました");
        } else {
          saveGameData(defaultGameData);
          console.log("デフォルトのゲームデータをIndexedDBに保存しました");
        }
      };
    }
    function saveGameData(data) {
      if(!dbInstance) return;
      const transaction = dbInstance.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      store.put(data);
    }
    function resetGameData() {
      if(!dbInstance) return;
      const transaction = dbInstance.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      const req = store.clear();
      req.onsuccess = function() {
        showToast("ゲームデータをリセットしました", "info");
        setTimeout(() => location.reload(), 1000);
      };
    }
    initDB();

    /***************************************
     * キーボード操作用 Mix-in
     ***************************************/
    const KeyOperationMixin = {
      methods: {
        handleKeyDown(e) {
          switch(e.key) {
            case 'ArrowUp':    this.move && this.move('up'); break;
            case 'ArrowDown':  this.move && this.move('down'); break;
            case 'ArrowLeft':  this.move && this.move('left'); break;
            case 'ArrowRight': this.move && this.move('right'); break;
            case 'p': case 'P': if(this.emitPropertyCheck) this.emitPropertyCheck(); break;
            case 'z': case 'Z': if(this.physicalAttack) this.physicalAttack(); break;
            case 'x': case 'X': if(this.openSpellMenu)  this.openSpellMenu(); break;
            case 'c': case 'C': if(this.runAway)        this.runAway(); break;
            case 'v': case 'V': if(this.openItemMenu)   this.openItemMenu(); break;
          }
        }
      },
      mounted() {
        window.addEventListener('keydown', this.handleKeyDown);
      },
      unmounted() {
        window.removeEventListener('keydown', this.handleKeyDown);
      }
    };

    /***************************************
     * FieldMap コンポーネント
     ***************************************/
    const FieldMap = {
      mixins: [KeyOperationMixin],
      props: ["initialHeroX", "initialHeroY", "heroStatus"],
      template: `
        <div>
          <h2 class="text-center mb-2">フィールドマップ(30×30)</h2>
          <div class="map-container" :style="containerStyle">
            <div v-for="row in viewportHeight" :key="row" style="display:flex;">
              <div v-for="col in viewportWidth" :key="col"
                   :class="['tile', tileType(row-1, col-1), isHeroTile(row-1, col-1) ? 'hero' : '']">
                {{ isHeroTile(row-1, col-1) ? '勇者' : tileLabel(row-1, col-1) }}
              </div>
            </div>
            <div v-if="message" class="message-window">{{ message }}</div>
          </div>
          <div class="control-panel">
            <div class="control-row">
              <button @touchstart.prevent="move('up')" @mousedown.prevent="move('up')" class="control-btn bg-blue-500 rounded-full">↑</button>
            </div>
            <div class="control-row">
              <button @touchstart.prevent="move('left')" @mousedown.prevent="move('left')" class="control-btn bg-blue-500 rounded-full">←</button>
              <button @touchstart.prevent="move('right')" @mousedown.prevent="move('right')" class="control-btn bg-blue-500 rounded-full">→</button>
            </div>
            <div class="control-row">
              <button @touchstart.prevent="move('down')" @mousedown.prevent="move('down')" class="control-btn bg-blue-500 rounded-full">↓</button>
            </div>
            <div class="control-row">
              <button @touchstart.prevent="emitPropertyCheck" @mousedown.prevent="emitPropertyCheck" class="control-btn bg-purple-500 rounded-full">Ｐ</button>
            </div>
          </div>
        </div>
      `,
      data() {
        return {
          worldW: 30,
          worldH: 30,
          viewportWidth: 10,
          viewportHeight: 10,
          heroX: this.initialHeroX || 0,
          heroY: this.initialHeroY || 0,
          mapData: [],
          message: "",
          isFrozen: false
        }
      },
      computed: {
        offsetX() {
          let ox = this.heroX - Math.floor(this.viewportWidth/2);
          if(ox < 0) ox = 0;
          if(ox > this.worldW - this.viewportWidth) ox = this.worldW - this.viewportWidth;
          return ox;
        },
        offsetY() {
          let oy = this.heroY - Math.floor(this.viewportHeight/2);
          if(oy < 0) oy = 0;
          if(oy > this.worldH - this.viewportHeight) oy = this.worldH - this.viewportHeight;
          return oy;
        },
        containerStyle() {
          if(this.heroStatus && this.heroStatus.maxHp) {
            return { border: (this.heroStatus.hp / this.heroStatus.maxHp <= 0.25 ? '4px solid red' : '4px solid #fff') };
          }
          return { border: '4px solid #fff' };
        }
      },
      methods: {
        initializeMap() {
          let data = [];
          for(let y = 0; y < this.worldH; y++){
            for(let x = 0; x < this.worldW; x++){
              let tile = { x, y, type: "grass", label: "" };
              if(x === 0 && y === 9) {
                tile.type = "townGate"; tile.label = "町";
              } else if(x === 5 && y === 5) {
                tile.type = "npc"; tile.label = "NPC";
              } else {
                const r = Math.random();
                if(r < 0.6) tile.type = "grass";
                else if(r < 0.8) tile.type = "road";
                else if(r < 0.9) tile.type = "forest";
                else if(r < 0.95) tile.type = "mountain";
                else tile.type = "water";
              }
              data.push(tile);
            }
          }
          this.mapData = data;
        },
        tileAt(vrow, vcol) {
          const wy = this.offsetY + vrow;
          const wx = this.offsetX + vcol;
          return this.mapData[wy * this.worldW + wx];
        },
        tileType(vrow, vcol) {
          const t = this.tileAt(vrow, vcol);
          return t ? t.type : "unknown";
        },
        tileLabel(vrow, vcol) {
          const t = this.tileAt(vrow, vcol);
          return t ? t.label : "???";
        },
        isHeroTile(vrow, vcol) {
          const wy = this.offsetY + vrow;
          const wx = this.offsetX + vcol;
          return (wx === this.heroX && wy === this.heroY);
        },
        showMessage(msg) {
          this.message = msg;
          setTimeout(() => { this.message = ""; }, 2000);
        },
        move(dir) {
          // モーダル中は移動不可
          if(Swal.isVisible()) return;
          if(this.isFrozen) return;
          let nx = this.heroX, ny = this.heroY;
          if(dir === "up" && ny > 0) ny--;
          if(dir === "down" && ny < this.worldH - 1) ny++;
          if(dir === "left" && nx > 0) nx--;
          if(dir === "right" && nx < this.worldW - 1) nx++;
          const tile = this.mapData[ny * this.worldW + nx];
          if(!tile) return;
          if(tile.type === "mountain" || tile.type === "water") {
            this.showMessage("そこは通れない！");
            return;
          }
          if(tile.type === "townGate") {
            this.heroX = nx; this.heroY = ny;
            this.$emit("update-field-position", { x: nx, y: ny });
            this.$emit("switch-scene", "town", { x: nx, y: ny });
            return;
          }
          this.heroX = nx; this.heroY = ny;
          this.$emit("update-field-position", { x: nx, y: ny });
          if(tile.type === "grass" && Math.random() < 0.1) {
            this.isFrozen = true;
            const enemy = this.generateEnemy();
            this.showMessage(`${enemy.name}があらわれた！`);
            setTimeout(() => {
              this.$emit("switch-scene", "battle", { x: nx, y: ny, enemy: enemy });
            }, 700);
          } else if(tile.type === "npc") {
            this.showMessage("「こんにちは、旅の人！」");
          }
        },
        generateEnemy() {
          const baseEnemies = defaultGameData.enemyData;
          let enemy = JSON.parse(JSON.stringify(baseEnemies[Math.floor(Math.random() * baseEnemies.length)]));
          enemy.maxHp = enemy.hp;
          enemy.speed = 5;
          enemy.canUseMagic = enemy.magicAttack > 0;
          return enemy;
        },
        emitPropertyCheck() {
          this.$emit("check-properties");
        }
      },
      mounted() {
        this.initializeMap();
      }
    };

    /***************************************
     * TownMap コンポーネント
     ***************************************/
    const TownMap = {
      mixins: [KeyOperationMixin],
      props: ["fieldEntrance", "heroStatus"],
      template: `
        <div>
          <h2 class="text-center mb-2">町マップ (20×20)</h2>
          <div class="map-container" :style="containerStyle">
            <div v-for="row in viewH" :key="row" style="display:flex;">
              <div v-for="col in viewW" :key="col"
                   :class="['tile', tileType(row-1, col-1), isHeroTile(row-1, col-1) ? 'hero' : '']"
                   @touchstart.prevent="onTileTouch(tileAt(row-1, col-1))"
                   @mousedown.prevent="onTileTouch(tileAt(row-1, col-1))">
                {{ isHeroTile(row-1, col-1) ? '勇者' : tileLabel(row-1, col-1) }}
              </div>
            </div>
            <div v-if="message" class="message-window">{{ message }}</div>
          </div>
          <div class="control-panel">
            <div class="control-row">
              <button @touchstart.prevent="move('up')" @mousedown.prevent="move('up')" class="control-btn bg-blue-500 rounded-full">↑</button>
            </div>
            <div class="control-row">
              <button @touchstart.prevent="move('left')" @mousedown.prevent="move('left')" class="control-btn bg-blue-500 rounded-full">←</button>
              <button @touchstart.prevent="move('right')" @mousedown.prevent="move('right')" class="control-btn bg-blue-500 rounded-full">→</button>
            </div>
            <div class="control-row">
              <button @touchstart.prevent="move('down')" @mousedown.prevent="move('down')" class="control-btn bg-blue-500 rounded-full">↓</button>
            </div>
            <div class="control-row">
              <button @touchstart.prevent="emitPropertyCheck" @mousedown.prevent="emitPropertyCheck" class="control-btn bg-purple-500 rounded-full">Ｐ</button>
            </div>
          </div>
        </div>
      `,
      data() {
        return {
          worldW: 20,
          worldH: 20,
          viewW: 10,
          viewH: 10,
          heroX: 5,
          heroY: 5,
          mapData: [],
          message: ""
        }
      },
      computed: {
        offsetX() {
          let ox = this.heroX - Math.floor(this.viewW / 2);
          if(ox < 0) ox = 0;
          if(ox > this.worldW - this.viewW) ox = this.worldW - this.viewW;
          return ox;
        },
        offsetY() {
          let oy = this.heroY - Math.floor(this.viewH / 2);
          if(oy < 0) oy = 0;
          if(oy > this.worldH - this.viewH) oy = this.worldH - this.viewH;
          return oy;
        },
        containerStyle() {
          if(this.heroStatus && this.heroStatus.maxHp) {
            return { border: (this.heroStatus.hp / this.heroStatus.maxHp <= 0.25 ? '4px solid red' : '4px solid #fff') };
          }
          return { border: '4px solid #fff' };
        }
      },
      methods: {
        initTown() {
          let arr = [];
          for(let y = 0; y < this.worldH; y++){
            for(let x = 0; x < this.worldW; x++){
              let tile = { x, y, type: "pavement", label: "" };
              if(y === 0 || y === this.worldH - 1 || x === 0 || x === this.worldW - 1) {
                tile.type = "exit";
              }
              if(x === 3 && y === 3) { tile.type = "building"; tile.label = "宿屋"; }
              if(x === 5 && y === 3) { tile.type = "building"; tile.label = "武器屋"; }
              if(x === 7 && y === 3) { tile.type = "building"; tile.label = "防具屋"; }
              if(x === 3 && y === 7) { tile.type = "building"; tile.label = "道具屋"; }
              if(x === 5 && y === 5) { tile.type = "npc"; tile.label = "NPC"; }
              arr.push(tile);
            }
          }
          this.mapData = arr;
        },
        tileIndex(vrow, vcol) {
          let wy = this.offsetY + vrow;
          let wx = this.offsetX + vcol;
          return wy * this.worldW + wx;
        },
        tileAt(vrow, vcol) {
          return this.mapData[this.tileIndex(vrow, vcol)];
        },
        tileType(r, c) {
          const t = this.tileAt(r, c);
          return t ? t.type : "?";
        },
        tileLabel(r, c) {
          const t = this.tileAt(r, c);
          return t ? t.label : "?";
        },
        isHeroTile(r, c) {
          let wy = this.offsetY + r;
          let wx = this.offsetX + c;
          return (wx === this.heroX && wy === this.heroY);
        },
        move(dir) {
          if(Swal.isVisible()) return;
          let nx = this.heroX, ny = this.heroY;
          if(dir === "up") ny--;
          if(dir === "down") ny++;
          if(dir === "left") nx--;
          if(dir === "right") nx++;
          if(nx < 0 || nx >= this.worldW || ny < 0 || ny >= this.worldH) {
            this.$emit("switch-scene", "field", this.fieldEntrance);
            return;
          }
          const tile = this.mapData[ny * this.worldW + nx];
          if(tile && tile.type === "exit") {
            this.$emit("switch-scene", "field", this.fieldEntrance);
            return;
          }
          if(tile && tile.type === "building") {
            this.showMessage(tile.label + "に入る");
            this.openShop(tile.label);
            return;
          }
          this.heroX = nx; this.heroY = ny;
          if(tile && tile.type === "npc") {
            this.showMessage("「こんにちは、旅の人！」");
          }
        },
        showMessage(msg) {
          this.message = msg;
          setTimeout(() => { this.message = ""; }, 2000);
        },
        openShop(label) {
          let items = [];
          let shopName = label;
          if(label === "宿屋") {
            showModal({
              title: shopName,
              text: "宿屋を利用します。HPとMPが最大まで回復します。",
              showCancelButton: true,
              cancelButtonText: "キャンセル",
              confirmButtonText: "回復する"
            }).then((result) => {
              if(result.isConfirmed) {
                this.$emit("update-status", { type: "setHP", amount: this.heroStatus.maxHp });
                this.heroStatus.mp = this.heroStatus.maxMp;
                showToast("HPとMPが全回復しました", "success");
              }
            });
            return;
          } else if(label === "武器屋") {
            items = defaultGameData.itemData.weapons;
          } else if(label === "防具屋") {
            items = defaultGameData.itemData.armors;
          } else if(label === "道具屋") {
            items = defaultGameData.itemData.consumables;
          }
          let htmlContent = `<p style="font-size:12px;">${shopName}の品揃え：</p>`;
          items.forEach((it, i) => {
            htmlContent += `<button id="shopitem-${i}" style="display:block;margin:3px 0;padding:5px;background:#222;color:#fff;font-size:12px;">
              ${it.name} (${it.price}G)
            </button>`;
          });
          if(label === "道具屋" && this.heroStatus.inventory.length > 0) {
            htmlContent += `<hr><p style="font-size:12px;">売却 (半額)：</p>`;
            this.heroStatus.inventory.forEach((invItem, idx) => {
              const sellPrice = Math.floor(invItem.price / 2);
              htmlContent += `<button id="sell-${idx}" style="display:block;margin:3px 0;padding:5px;background:#2a2a2a;color:#fff;font-size:12px;">
                売却: ${invItem.name} (${sellPrice}G)
              </button>`;
            });
          }
          showModal({
            title: shopName,
            html: htmlContent,
            showCancelButton: true,
            cancelButtonText: '閉じる',
            confirmButtonText: '何もしない'
          });
          setTimeout(() => {
            items.forEach((it, i) => {
              const btn = document.getElementById(`shopitem-${i}`);
              if(btn){
                btn.addEventListener('click', () => {
                  this.$emit("update-status", { type: "buy", item: it });
                  showToast(`${it.name}を購入しました`);
                  Swal.close();
                });
              }
            });
            if(label === "道具屋") {
              this.heroStatus.inventory.forEach((invItem, idx) => {
                const sellBtn = document.getElementById(`sell-${idx}`);
                if(sellBtn){
                  sellBtn.addEventListener('click', () => {
                    this.$emit("update-status", { type: "sell", item: invItem });
                    showToast(`${invItem.name}を売却しました`, "info");
                    Swal.close();
                  });
                }
              });
            }
          }, 200);
        },
        onTileTouch(tile) {
          if(tile && tile.type === "npc") {
            this.showMessage("NPC: 「こんにちは！」");
          } else if(tile && tile.type === "building") {
            this.showMessage(tile.label + "に入る");
            this.openShop(tile.label);
          }
        },
        emitPropertyCheck() {
          this.$emit("check-properties");
        }
      },
      mounted() {
        this.initTown();
      }
    };

    /***************************************
     * BattleScene コンポーネント
     ***************************************/
    const BattleScene = {
      mixins: [KeyOperationMixin],
      props: ["initialHeroHP", "enemy", "heroStatus", "calcFinalAttack", "calcFinalDefense"],
      template: `
        <div class="battle-container" :style="containerStyle">
          <div class="battle-top">
            <div class="battle-left">
              <h3>勇者</h3>
              <p>HP: {{ heroHP }} / {{ heroMaxHP }}</p>
              <p>MP: {{ heroStatus.mp }} / {{ heroStatus.maxMp }}</p>
              <p>攻: {{ calcFinalAttack(heroStatus) }}</p>
              <p>守: {{ calcFinalDefense(heroStatus) }}</p>
              <p>LV: {{ heroStatus.level }}</p>
              <p>EXP: {{ heroStatus.exp }}</p>
            </div>
            <div class="battle-center">
              <div style="width:120px; height:120px; background-color:#444; display:flex; align-items:center; justify-content:center;">
                {{ enemy.name }}
              </div>
            </div>
            <div class="battle-right">
              <h3>敵</h3>
              <p>HP: {{ enemyHP }} / {{ enemyMaxHP }}</p>
              <p>攻: {{ enemy.attack }}</p>
              <p>守: {{ enemy.defense }}</p>
              <p>魔攻: {{ enemy.magicAttack }}</p>
              <p>魔防: {{ enemy.magicDefense }}</p>
            </div>
          </div>
          <div class="battle-footer">
            <div class="message-area">
              <p v-for="(line, i) in battleMessageLines" :key="i">{{ line }}</p>
            </div>
            <div class="actions">
              <button id="attack-button" @touchstart.prevent="physicalAttack" @mousedown.prevent="physicalAttack" class="bg-blue-500 rounded">攻撃</button>
              <button @touchstart.prevent="openSpellMenu" @mousedown.prevent="openSpellMenu" class="bg-indigo-500 rounded">魔法</button>
              <button @touchstart.prevent="runAway" @mousedown.prevent="runAway" class="bg-yellow-500 rounded">逃げる</button>
              <button @touchstart.prevent="openItemMenu" @mousedown.prevent="openItemMenu" class="bg-green-500 rounded">道具</button>
            </div>
          </div>
        </div>
      `,
      data() {
        return {
          heroHP: this.initialHeroHP,
          heroMaxHP: this.heroStatus.maxHp,
          enemyHP: this.enemy.hp,
          enemyMaxHP: this.enemy.maxHp,
          messageHistory: []
        }
      },
      computed: {
        battleMessageLines() {
          return this.messageHistory.slice(-5).reverse();
        },
        containerStyle() {
          if(this.heroStatus && this.heroStatus.maxHp) {
            return { border: (this.heroStatus.hp / this.heroStatus.maxHp <= 0.25 ? '4px solid red' : '4px solid #fff') };
          }
          return { border: '4px solid #fff' };
        },
        heroSpells() {
          let spells = [];
          if(this.heroStatus.learnedSpells.includes("ギラ")){
            spells.push({ name: "ギラ", mpCost: 3, type: "attack", power: 7 });
          }
          if(this.heroStatus.learnedSpells.includes("ホイミ")){
            spells.push({ name: "ホイミ", mpCost: 3, type: "heal", power: 12 });
          }
          return spells;
        }
      },
      methods: {
        appendMsg(line) { this.messageHistory.push(line); },
        physicalAttack() {
          const dmg = Math.max(0, this.calcFinalAttack(this.heroStatus) - this.enemy.defense);
          this.enemyHP -= dmg;
          this.appendMsg(`勇者の攻撃！ ${this.enemy.name}に${dmg}ダメージ`);
          this.checkEnemyStatus();
        },
        checkEnemyStatus() {
          if(this.enemyHP <= 0) {
            this.enemyHP = 0;
            this.appendMsg(`${this.enemy.name}を倒した！`);
            setTimeout(() => {
              showToast(`${this.enemy.name}を倒した！`);
              const r = this.enemy.reward || { gold: 0, exp: 0 };
              this.$emit("update-status", { type: "reward", reward: r });
              this.$emit("switch-scene", "field");
            }, 800);
          } else {
            setTimeout(() => { this.enemyTurn(); }, 800);
          }
        },
        enemyTurn() {
          let dmg = 0;
          if(this.enemy.canUseMagic && Math.random() < 0.5) {
            dmg = Math.max(0, this.enemy.magicAttack);
            this.appendMsg(`敵の魔法攻撃！ 勇者に${dmg}ダメージ`);
          } else {
            dmg = Math.max(0, this.enemy.attack - Math.floor(this.calcFinalDefense(this.heroStatus)/2));
            this.appendMsg(`敵の攻撃！ 勇者に${dmg}ダメージ`);
          }
          this.heroHP -= dmg;
          this.heroStatus.hp = this.heroHP;
          if(this.heroHP <= 0) {
            this.heroHP = 0;
            this.appendMsg("勇者は倒れた…");
            setTimeout(() => {
              this.$emit("update-status", { type: "setHP", amount: this.heroMaxHP });
              this.$emit("switch-scene", "field");
            }, 800);
          }
        },
        openSpellMenu() {
          if(this.heroSpells.length === 0) {
            showToast("使用できる魔法がない", "info");
            return;
          }
          let html = `<p style="font-size:12px;">使う魔法を選択：</p>`;
          this.heroSpells.forEach((sp, i) => {
            html += `<button id="spell-${i}" style="display:block;width:100%;margin:3px 0;padding:5px;background:#222;color:#fff;font-size:12px;">
              ${sp.name}(MP:${sp.mpCost})
            </button>`;
          });
          showModal({
            title: '呪文',
            html,
            showCancelButton: true,
            cancelButtonText: 'やめる',
            confirmButtonText: '何もしない'
          });
          setTimeout(() => {
            this.heroSpells.forEach((sp, i) => {
              const btn = document.getElementById(`spell-${i}`);
              if(btn){
                btn.addEventListener('click', () => {
                  this.castSpell(sp);
                  Swal.close();
                });
              }
            });
          }, 200);
        },
        castSpell(sp) {
          if(this.heroStatus.mp < sp.mpCost) {
            showToast("MPが足りません！", "error");
            return;
          }
          this.heroStatus.mp -= sp.mpCost;
          if(sp.type === "attack") {
            let dmg = Math.max(0, sp.power - (this.enemy.magicDefense || 0));
            this.enemyHP -= dmg;
            this.appendMsg(`${sp.name}発動！ ${this.enemy.name}に${dmg}ダメージ`);
            this.checkEnemyStatus();
          } else if(sp.type === "heal") {
            let recov = sp.power;
            this.heroHP = Math.min(this.heroHP + recov, this.heroMaxHP);
            this.appendMsg(`${sp.name}発動！ 勇者HPが${recov}回復`);
          }
        },
        runAway() {
          if(Math.random() < 0.5) {
            showToast("逃走成功", "info");
            this.$emit("switch-scene", "field");
          } else {
            this.appendMsg("逃走失敗！");
            setTimeout(() => { this.enemyTurn(); }, 600);
          }
        },
        openItemMenu() {
          if(this.heroStatus.inventory.length === 0) {
            showToast("道具はない", "info");
            return;
          }
          let html = `<p style="font-size:12px;">使う道具を選択：</p>`;
          this.heroStatus.inventory.forEach((it, i) => {
            html += `<button id="item-${i}" style="display:block;width:100%;margin:3px 0;padding:5px;background:#444;color:#fff;font-size:12px;">
              ${it.name} (効果:${it.effect||"?"})
            </button>`;
          });
          showModal({
            title: '道具',
            html,
            showCancelButton: true,
            cancelButtonText: 'やめる',
            confirmButtonText: '何もしない'
          });
          setTimeout(() => {
            this.heroStatus.inventory.forEach((it, i) => {
              const btn = document.getElementById(`item-${i}`);
              if(btn){
                btn.addEventListener('click', () => {
                  this.useItem(it);
                  Swal.close();
                });
              }
            });
          }, 200);
        },
        useItem(it) {
          if(it.effect === "smallHeal") {
            this.heroHP = Math.min(this.heroHP + 10, this.heroMaxHP);
            this.appendMsg(`${it.name}を使用しHP+10`);
          } else if(it.effect === "curePoison") {
            this.appendMsg("毒が治った！");
          }
          const idx = this.heroStatus.inventory.findIndex(x => x.name === it.name);
          if(idx >= 0) this.heroStatus.inventory.splice(idx, 1);
          setTimeout(() => { this.enemyTurn(); }, 500);
        }
      },
      mounted() {
        this.$nextTick(() => {
          const btn = document.getElementById("attack-button");
          if(btn) btn.focus();
        });
      }
    };

    /***************************************
     * ルート RootApp コンポーネント
     ***************************************/
    const RootApp = {
      template: `
        <div>
          <component :is="currentSceneComp"
            @switch-scene="switchScene"
            @update-status="updateStatus"
            @check-properties="checkProperties"
            @update-field-position="updateFieldPos"
            :initial-hero-x="fieldPos.x"
            :initial-hero-y="fieldPos.y"
            :field-entrance="fieldEntrance"
            :hero-status="heroStatus"
            :enemy="currentEnemy"
            :calc-final-attack="calcFinalAttack"
            :calc-final-defense="calcFinalDefense"
          ></component>
        </div>
      `,
      data(){
        return {
          currentScene: "field",
          fieldEntrance: { x: 0, y: 9 },
          fieldPos: { x: 0, y: 9 },
          heroStatus: {
            level: 1, exp: 0, nextExp: 10,
            hp: 15, maxHp: 15,
            mp: 5, maxMp: 5,
            attack: 5, defense: 3, speed: 10,
            gold: 1000,
            weapon: null, armor: null,
            learnedSpells: ["ホイミ"],
            inventory: []
          },
          currentEnemy: null
        }
      },
      computed: {
        currentSceneComp() {
          if(this.currentScene === "field") return FieldMap;
          else if(this.currentScene === "town") return TownMap;
          else if(this.currentScene === "battle"){
            return {
              render: () => Vue.h(BattleScene, {
                initialHeroHP: this.heroStatus.hp,
                enemy: this.currentEnemy,
                heroStatus: this.heroStatus,
                calcFinalAttack: this.calcFinalAttack,
                calcFinalDefense: this.calcFinalDefense
              })
            }
          }
        },
        equippableItems() {
          return this.heroStatus.inventory.filter(item => item.type === "weapon" || item.type === "armor");
        }
      },
      methods: {
        switchScene(scene, payload) {
          if(scene === "field") {
            // 戦闘後は座標維持
          } else if(scene === "town") {
            if(payload) this.fieldPos = payload;
          } else if(scene === "battle") {
            if(payload && payload.enemy) this.currentEnemy = payload.enemy;
          }
          this.currentScene = scene;
        },
        updateStatus(payload) {
          if(payload.type === "buy") {
            const it = payload.item;
            if(this.heroStatus.gold >= it.price) {
              this.heroStatus.gold -= it.price;
              if(it.type === "consumable") {
                if(it.effect !== "healFromInn") {
                  this.heroStatus.inventory.push(it);
                }
              } else if(it.type === "weapon") {
                if(this.heroStatus.weapon) {
                  this.heroStatus.inventory.push(this.heroStatus.weapon);
                }
                this.heroStatus.weapon = it;
                showToast(`${it.name} (武器) を装備しました`, "info");
              } else if(it.type === "armor") {
                if(this.heroStatus.armor) {
                  this.heroStatus.inventory.push(this.heroStatus.armor);
                }
                this.heroStatus.armor = it;
                showToast(`${it.name} (防具) を装備しました`, "info");
              }
              showToast(`${it.name}を購入しました`);
            } else {
              showModal({ icon: 'error', text: "お金が足りません" });
            }
          } else if(payload.type === "sell") {
            const it = payload.item;
            if(it.type === "weapon" && this.heroStatus.weapon && this.heroStatus.weapon.name === it.name) {
              this.heroStatus.weapon = null;
            } else if(it.type === "armor" && this.heroStatus.armor && this.heroStatus.armor.name === it.name) {
              this.heroStatus.armor = null;
            }
            const idx = this.heroStatus.inventory.findIndex(x => x.name === it.name);
            if(idx >= 0) this.heroStatus.inventory.splice(idx, 1);
            const sp = Math.floor(it.price / 2);
            this.heroStatus.gold += sp;
            showToast(`${it.name}を売却しました`, "info");
          } else if(payload.type === "reward") {
            const r = payload.reward;
            this.heroStatus.gold += (r.gold || 0);
            this.heroStatus.exp += (r.exp || 0);
            this.checkLevelUp();
          } else if(payload.type === "setHP") {
            this.heroStatus.hp = payload.amount;
          }
        },
        checkLevelUp() {
          const table = defaultGameData.levelUpCriteria;
          let leveledUp = false;
          let messages = [];
          while(this.heroStatus.level <= table.length && this.heroStatus.exp >= table[this.heroStatus.level - 1]) {
            this.heroStatus.level++;
            const inc = { hp: 5, mp: 3, attack: 2, defense: 1 };
            this.heroStatus.maxHp += inc.hp;
            this.heroStatus.maxMp += inc.mp;
            this.heroStatus.attack += inc.attack;
            this.heroStatus.defense += inc.defense;
            messages.push(`レベル${this.heroStatus.level}に上がりました！ [HP+${inc.hp}, MP+${inc.mp}, 攻撃+${inc.attack}, 守備+${inc.defense}]`);
            if(this.heroStatus.level === 2 && !this.heroStatus.learnedSpells.includes("ギラ")){
              this.heroStatus.learnedSpells.push("ギラ");
              messages.push("新たに『ギラ』を習得しました！");
            }
            leveledUp = true;
          }
          if(this.heroStatus.level <= table.length) {
            this.heroStatus.nextExp = table[this.heroStatus.level - 1];
          } else {
            this.heroStatus.nextExp = "-";
          }
          if(leveledUp) {
            messages.forEach(m => {
              showToast(m, "info");
            });
          }
        },
        calcFinalAttack(hero) {
          let wAtk = hero.weapon ? hero.weapon.power : 0;
          return hero.attack + wAtk;
        },
        calcFinalDefense(hero) {
          let aDef = hero.armor ? hero.armor.power : 0;
          return hero.defense + aDef;
        },
        checkProperties() {
          const w = this.heroStatus.weapon ? this.heroStatus.weapon.name : "(なし)";
          const a = this.heroStatus.armor ? this.heroStatus.armor.name : "(なし)";
          const inv = (this.heroStatus.inventory.length > 0) ? this.heroStatus.inventory.map(x => x.name).join(", ") : "(なし)";
          let html = `<pre>
【勇者ステータス】
LV: ${this.heroStatus.level}
EXP: ${this.heroStatus.exp} (次: ${this.heroStatus.nextExp || "?"})
HP: ${this.heroStatus.hp}/${this.heroStatus.maxHp}
MP: ${this.heroStatus.mp}/${this.heroStatus.maxMp}
攻: ${this.calcFinalAttack(this.heroStatus)}
守: ${this.calcFinalDefense(this.heroStatus)}
Gold: ${this.heroStatus.gold}
呪文: ${this.heroStatus.learnedSpells.join(", ") || "なし"}
</pre>`;
          html += `<div class="modal-section">
<h3 style="font-size:14px;">装備</h3>
<p>武器: ${w}</p>
<p>防具: ${a}</p>
</div>`;
          const equippable = this.heroStatus.inventory.filter(item => item.type === "weapon" || item.type === "armor");
          if(equippable.length > 0) {
            html += `<div class="modal-section">
<h3 style="font-size:14px;">装備変更 (在庫)</h3>`;
            equippable.forEach((item, index) => {
              html += `<button id="equip-${index}" style="display:block;width:100%;margin:3px 0;padding:5px;background:#222;color:#fff;font-size:12px;">
装備: ${item.name} (${item.type})
</button>`;
            });
            html += `</div>`;
          }
          const consumables = this.heroStatus.inventory.filter(item => item.type === "consumable");
          if(consumables.length > 0) {
            html += `<div class="modal-section">
<h3 style="font-size:14px;">道具使用</h3>`;
            consumables.forEach((item, index) => {
              html += `<button id="use-${index}" style="display:block;width:100%;margin:3px 0;padding:5px;background:#444;color:#fff;font-size:12px;">
使用: ${item.name} (効果: ${item.effect})
</button>`;
            });
            html += `</div>`;
          }
          if(this.currentScene !== "battle") {
            const spells = this.heroStatus.learnedSpells.map(sp => {
              if(sp === "ギラ") return { name: "ギラ", mpCost: 3, type: "attack", power: 7 };
              else if(sp === "ホイミ") return { name: "ホイミ", mpCost: 3, type: "heal", power: 12 };
              else if(sp === "ベギラマ") return { name: "ベギラマ", mpCost: 5, type: "attack", power: 15 };
            }).filter(x => x && x.type === "heal");
            if(spells.length > 0) {
              html += `<div class="modal-section">
<h3 style="font-size:14px;">魔法使用</h3>`;
              spells.forEach((spell, index) => {
                html += `<button id="spellprop-${index}" style="display:block;width:100%;margin:3px 0;padding:5px;background:#666;color:#fff;font-size:12px;">
発動: ${spell.name} (MP:${spell.mpCost})
</button>`;
              });
              html += `</div>`;
            }
          }
          html += `<div class="modal-section">
<button id="resetGame" style="display:block;width:100%;margin:3px 0;padding:5px;background:#aa0000;color:#fff;font-size:12px;">
ゲームリセット
</button>
</div>`;
          showModal({
            title: "勇者のステータス",
            html: html,
            showCancelButton: true,
            cancelButtonText: "閉じる"
          }).then(() => {});
          setTimeout(() => {
            equippable.forEach((item, index) => {
              const btn = document.getElementById(`equip-${index}`);
              if(btn) {
                btn.addEventListener('click', () => {
                  this.equipItemFromProperties(item);
                  Swal.close();
                });
              }
            });
            consumables.forEach((item, index) => {
              const btn = document.getElementById(`use-${index}`);
              if(btn) {
                btn.addEventListener('click', () => {
                  this.useItemFromProperties(item);
                  Swal.close();
                });
              }
            });
            if(this.currentScene !== "battle") {
              const spells = this.heroStatus.learnedSpells.map(sp => {
                if(sp === "ギラ") return { name: "ギラ", mpCost: 3, type: "attack", power: 7 };
                else if(sp === "ホイミ") return { name: "ホイミ", mpCost: 3, type: "heal", power: 12 };
                else if(sp === "ベギラマ") return { name: "ベギラマ", mpCost: 5, type: "attack", power: 15 };
              }).filter(x => x && x.type === "heal");
              spells.forEach((spell, index) => {
                const btn = document.getElementById(`spellprop-${index}`);
                if(btn) {
                  btn.addEventListener('click', () => {
                    this.castSpellFromProperties(spell);
                    Swal.close();
                  });
                }
              });
            }
            const resetBtn = document.getElementById("resetGame");
            if(resetBtn) {
              resetBtn.addEventListener('click', () => {
                resetGameData();
                Swal.close();
              });
            }
          }, 200);
        },
        equipItemFromProperties(item) {
          if(item.type === "weapon") {
            if(this.heroStatus.weapon) {
              this.heroStatus.inventory.push(this.heroStatus.weapon);
            }
            const idx = this.heroStatus.inventory.findIndex(x => x.name === item.name);
            if(idx >= 0) this.heroStatus.inventory.splice(idx, 1);
            this.heroStatus.weapon = item;
            showToast(`${item.name} (武器) を装備しました`, "info");
          } else if(item.type === "armor") {
            if(this.heroStatus.armor) {
              this.heroStatus.inventory.push(this.heroStatus.armor);
            }
            const idx = this.heroStatus.inventory.findIndex(x => x.name === item.name);
            if(idx >= 0) this.heroStatus.inventory.splice(idx, 1);
            this.heroStatus.armor = item;
            showToast(`${item.name} (防具) を装備しました`, "info");
          }
        },
        useItemFromProperties(item) {
          if(item.effect === "smallHeal") {
            this.heroStatus.hp = Math.min(this.heroStatus.hp + 10, this.heroStatus.maxHp);
            showToast(`${item.name}でHPが10回復しました`, "success");
          } else if(item.effect === "curePoison") {
            showToast(`${item.name}で毒が治りました`, "success");
          } else if(item.effect === "returnTown") {
            showToast(`${item.name}で町に帰還します`, "info");
            setTimeout(() => { this.switchScene("town", this.fieldEntrance); }, 1500);
            return;
          }
          const idx = this.heroStatus.inventory.findIndex(x => x.name === item.name);
          if(idx >= 0) this.heroStatus.inventory.splice(idx, 1);
        },
        castSpellFromProperties(spell) {
          if(this.heroStatus.mp < spell.mpCost) {
            showToast("MPが足りません！", "error");
            return;
          }
          this.heroStatus.mp -= spell.mpCost;
          if(spell.type === "heal") {
            let rec = spell.power;
            this.heroStatus.hp = Math.min(this.heroStatus.hp + rec, this.heroStatus.maxHp);
            showToast(`${spell.name}でHPが${rec}回復しました`, "success");
          } else {
            showToast("攻撃魔法は戦闘中のみ使用可能", "info");
          }
        },
        updateFieldPos(pos) {
          this.fieldPos = pos;
        },
        spaceKeyHandler(e) {
          if(e.key === " ") {
            this.checkProperties();
          }
        }
      },
      mounted() {
        window.addEventListener('keydown', (e) => {
          if(e.key === " ") { this.checkProperties(); }
        });
      }
    };

    /***************************************
     * ルート RootApp の初期化
     ***************************************/
    Vue.createApp(RootApp).mount("#app");
  </script>
</body>
</html>
